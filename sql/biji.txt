

	表是一种结构化文件  
DQL :
	数据查询语言（凡是带有select关键字的都是查询语句）
	select ...
 
DML :
	数据操作语言（凡是对表当中的数据进行增删改的都是DML）
	insert 增
	delete 删
	update 改
DDL : 	
	数据定义语言
	凡是带有create、drop、alter的都是DDL
	DDL主要操作的是表的结构，不是表中的数据
	create ： 新建 ，增
	drop ： 删除
	alter ： 修改
	这个增删改和DML不同，这个主要是对表结构进行操作
TCL ： 
	事务控制语言
	包括
		事务提交 ： commit
		事务回滚 ： rollback
DCL ：
	数据控制语言
	例如 ： 授权 grant ， 撤销权限 revoke ....


标准sql语句中要求字符串使用单引号括起来，虽然mysql支持双引号，但是不通用


简单查询 ： 

	去重 ： 
		select distinct JOB from EMP;
			distinct 只能出现在所有字段的最前面 
	查询不同工作岗位的数量
		select count(distinct JOB) from EMP;
	查询不同部门，不同工作岗位的数量
		select count(distinct DEPTNO , JOB) from EMP;
	查看表的创建语句 
		show create table EMP ;  

	导入表 ：
		source 路径 
	不看表中的数据，只看表的结构 ： 
		desc 表名 
	查看mysql 版本
		select  version();
	查看当前操作的数据库
		select database();
	查看字段内容
		select * from dept;
		select dname from dept;
		select dname , deptno from dept;
	使用别名 查看表
		select DNAME as dname , DEPTNO as deptno from DEPT;
		select DNAME  dname , DEPTNO  'dept no' from DEPT;
	查询员工年薪? (字段可以参与数学运算)
		select ENAME , SAL * 12 from EMP;
	找出工资在1100 和 3000 之间的员工，包括1100 和3000
		select ENAME,SAL from EMP where sal <= 3000 and sal >= 1100;
		select ENAME,SAL from EMP where sal between 1100 and 3000;
								between ... and ...   为闭区间  左小右大
	查询字段为空
		select * from EMP where COMM is null;
			空不是一个值，不能用等号衡量，
	找出薪资大于1000 的并且部门编号是20 或者 部门编号30的员工
		select ENAME , JOB , SAL from EMP where (DEPTNO = 20 or DEPTNO = 30) and SAL >= 3000;
				and 的优先级比 or 高
				注意 ： 当运算符的优先级不确定的时候加小括号
	like   % _   
		% 代表多个任意字符
		_ 代表一个任意字符
		转义字符 \
	 
	 排序   默认升序
	 	select ENAME ,SAL from  EMP  order by SAL desc;   降序
		select ENAME ,SAL from  EMP  order by SAL asc;    升序
	按照工资的降序排列，当工资相同的时候再按照名字的升序进行排列
		select * from EMP order by SAL desc , ENAME asc;
			前面字段相同的情况下，后面的字段才会被启用
			越靠前的字段，越能起到主导作用，只有当前面的字段无法完成排序的时候，才会启用后面的字段

		select * from EMP where JOB = 'SALESMAN' order by SAL desc , ENAME desc;
			先执行 from 再执行 where  再执行 select 再执行 order by 



分组函数
	count  计数
	sum    求和
	avg    平均值
	max    最大值
	min    最小值
	记住 ： 所有的分组函数都是对 某一组 数据进行操作的
			**********分组函数自动忽略NULL********
	只要有null参与的运算结果一定是null 

	count(*) 和 count(具体某个字段) , 有什么区别
	 	count(*) 不是统计某个字段中数据的个数，而是统计总记录的个数 ， ***和某个字段无关***
		count(COMM)  表示统计COMM字段中部位NULL的数据总量
	从EMP中找出薪资大于平均薪资的姓名及其薪资并进行降序排列
		select ENAME,SAL from EMP where SAL > (select avg(SAL) from EMP) order by SAL desc;


group by 和 having
	group by : 按照某噶尔字段或者某些字段进行分组
	having  ： having是对分组之后的数据进行再次过滤
	注意 ： 分组函数一般都会和group by 联合使用，这要是为什么他被成为分组函数的原因
			并且任何一个分组函数(count , sum ,avg , max, min ) 都是在group by 语句执行结束后才会执行的
			当一条sql语句没有group by的话， 整张表的数据会自成一组
	******************select 一定会在 group by 后面执行************

select      5
	..
from        1
	..
where       2
	..
group by    3
	.. 
having      4
	..
order by    6
	..
	select ENAME from EMP where SAL > avg(SAL ) ; 
		错误的原因  当sql语句不进行分组时， 在最后会自动添加 group by 
	相当于 ==  select ENAME from EMP where SAL > avg(SAL) group by ;
		没有组 avg 不知道那些成组， 所以 语句会报错
****************************************
当一条语句中有group by 的话， select 后面只能跟分组函数和参与分组的字段 
****************************************	
	多字段联合分组查询
		找出每个部门不同工作岗位的最高薪资
			select 
				DEPTNO , JOB , max(SAL)
			from 
				EMP
			group by 
				DEPTNO , JOB ;
			
	找出各部门薪资的最高工资，并且最高工资大于2900
		select 								select
			max(SAL) , DEPTNO                		max(SAL) , DEPTNO
		from 								from
			EMP 									EMP
		where								group by 
			SAL > 2900								DEPTNO 
		group by           					having  
			DEPTNO ; 								max(SAL) > 2900;
			高效率                              低效率



连接查询
	在实际开发，大多数情况都不是单表查询数据，一般都是多张表联合查询取出最终的结果
		一般一个业务都会对应多张表，比如学生和班级，起码两张表

	根据表的连接方式来划分
		内连接 ： 
			等值连接
			非等值连接
			自连接
		外链接 ：
			左外连接
			右外连接
		全连接 ：  基本不用
			
			表别名（笛卡尔积）
				查询每个员工的部门名称 ， 要求显示员工名和部门名
					select e.ENAME , d.DNAME from EMP e , DEPT d where e.DEPTNO = d.DEPTNO;
					select e.ENAME , d.DNAME from EMP e join DEPT d on e.DEPTNO = d.DEPTNO ; 
					select e.ENAME , d.DNAME from EMP e , DEPT d ;